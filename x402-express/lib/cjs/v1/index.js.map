{"version":3,"sources":["../../../src/v1/index.ts","../../../src/exact/v1/client/scheme.ts","../../../src/constants.ts","../../../src/utils.ts","../../../src/exact/v1/facilitator/scheme.ts"],"sourcesContent":["/**\n * V1 exports for the SVM mechanism\n */\nexport { ExactSvmSchemeV1 } from \"../exact/v1\";\n\nexport const NETWORKS: string[] = [\"solana\", \"solana-devnet\", \"solana-testnet\"];\n","import {\n  getSetComputeUnitLimitInstruction,\n  setTransactionMessageComputeUnitPrice,\n} from \"@solana-program/compute-budget\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport {\n  fetchMint,\n  findAssociatedTokenPda,\n  getTransferCheckedInstruction,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport {\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  getBase64EncodedWireTransaction,\n  partiallySignTransactionMessageWithSigners,\n  pipe,\n  prependTransactionMessageInstruction,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  type Address,\n} from \"@solana/kit\";\nimport type {\n  Network,\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkClient,\n} from \"@x402/core/types\";\nimport type { PaymentRequirementsV1 } from \"@x402/core/types/v1\";\nimport {\n  DEFAULT_COMPUTE_UNIT_LIMIT,\n  DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS,\n} from \"../../../constants\";\nimport type { ClientSvmConfig, ClientSvmSigner } from \"../../../signer\";\nimport type { ExactSvmPayloadV1 } from \"../../../types\";\nimport { createRpcClient } from \"../../../utils\";\n\n/**\n * SVM client implementation for the Exact payment scheme (V1).\n */\nexport class ExactSvmSchemeV1 implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactSvmClientV1 instance.\n   *\n   * @param signer - The SVM signer for client operations\n   * @param config - Optional configuration with custom RPC URL\n   * @returns ExactSvmClientV1 instance\n   */\n  constructor(\n    private readonly signer: ClientSvmSigner,\n    private readonly config?: ClientSvmConfig,\n  ) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme (V1).\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @returns Promise resolving to a payment payload\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<\n    Pick<PaymentPayload, \"x402Version\" | \"payload\"> & { scheme: string; network: Network }\n  > {\n    const selectedV1 = paymentRequirements as unknown as PaymentRequirementsV1;\n    const rpc = createRpcClient(selectedV1.network, this.config?.rpcUrl);\n\n    const tokenMint = await fetchMint(rpc, selectedV1.asset as Address);\n    const tokenProgramAddress = tokenMint.programAddress;\n\n    if (\n      tokenProgramAddress.toString() !== TOKEN_PROGRAM_ADDRESS.toString() &&\n      tokenProgramAddress.toString() !== TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      throw new Error(\"Asset was not created by a known token program\");\n    }\n\n    const [sourceATA] = await findAssociatedTokenPda({\n      mint: selectedV1.asset as Address,\n      owner: this.signer.address,\n      tokenProgram: tokenProgramAddress,\n    });\n\n    const [destinationATA] = await findAssociatedTokenPda({\n      mint: selectedV1.asset as Address,\n      owner: selectedV1.payTo as Address,\n      tokenProgram: tokenProgramAddress,\n    });\n\n    const transferIx = getTransferCheckedInstruction(\n      {\n        source: sourceATA,\n        mint: selectedV1.asset as Address,\n        destination: destinationATA,\n        authority: this.signer,\n        amount: BigInt(selectedV1.maxAmountRequired),\n        decimals: tokenMint.data.decimals,\n      },\n      { programAddress: tokenProgramAddress },\n    );\n\n    // Facilitator must provide feePayer to cover transaction fees\n    const feePayer = selectedV1.extra?.feePayer as Address;\n    if (!feePayer) {\n      throw new Error(\"feePayer is required in paymentRequirements.extra for SVM transactions\");\n    }\n\n    const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\n    const tx = pipe(\n      createTransactionMessage({ version: 0 }),\n      tx => setTransactionMessageComputeUnitPrice(DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS, tx),\n      tx => setTransactionMessageFeePayer(feePayer, tx),\n      tx =>\n        prependTransactionMessageInstruction(\n          getSetComputeUnitLimitInstruction({ units: DEFAULT_COMPUTE_UNIT_LIMIT }),\n          tx,\n        ),\n      tx => appendTransactionMessageInstructions([transferIx], tx),\n      tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    );\n\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(tx);\n    const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n    const payload: ExactSvmPayloadV1 = {\n      transaction: base64EncodedWireTransaction,\n    };\n\n    return {\n      x402Version,\n      scheme: selectedV1.scheme,\n      network: selectedV1.network,\n      payload,\n    };\n  }\n}\n","/**\n * Token program addresses for SPL Token and Token-2022\n * These addresses are the same across all Solana networks (mainnet, devnet, testnet)\n */\nexport const TOKEN_PROGRAM_ADDRESS = \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\nexport const TOKEN_2022_PROGRAM_ADDRESS = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\nexport const COMPUTE_BUDGET_PROGRAM_ADDRESS = \"ComputeBudget111111111111111111111111111111\";\n\n/**\n * Default RPC URLs for Solana networks\n */\nexport const DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\nexport const TESTNET_RPC_URL = \"https://api.testnet.solana.com\";\nexport const MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\nexport const DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\nexport const TESTNET_WS_URL = \"wss://api.testnet.solana.com\";\nexport const MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\n\n/**\n * USDC token mint addresses (default stablecoin)\n */\nexport const USDC_MAINNET_ADDRESS = \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\";\nexport const USDC_DEVNET_ADDRESS = \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\";\nexport const USDC_TESTNET_ADDRESS = \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\"; // Same as devnet\n\n/**\n * Compute budget configuration\n * All prices are in microlamports (1 lamport = 1,000,000 microlamports)\n */\nexport const DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 1;\nexport const MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 5_000_000; // 5 lamports\nexport const DEFAULT_COMPUTE_UNIT_LIMIT = 6500;\n\n/**\n * Solana address validation regex (base58, 32-44 characters)\n */\nexport const SVM_ADDRESS_REGEX = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n\n/**\n * CAIP-2 network identifiers for Solana (V2)\n */\nexport const SOLANA_MAINNET_CAIP2 = \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\";\nexport const SOLANA_DEVNET_CAIP2 = \"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1\";\nexport const SOLANA_TESTNET_CAIP2 = \"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z\";\n\n/**\n * V1 to V2 network identifier mappings (for backwards compatibility)\n * V1 used simple names like solana, V2 uses CAIP-2\n */\nexport const V1_TO_V2_NETWORK_MAP: Record<string, string> = {\n  solana: SOLANA_MAINNET_CAIP2,\n  \"solana-devnet\": SOLANA_DEVNET_CAIP2,\n  \"solana-testnet\": SOLANA_TESTNET_CAIP2,\n};\n","import {\n  getBase64Encoder,\n  getTransactionDecoder,\n  getCompiledTransactionMessageDecoder,\n  type Transaction,\n  createSolanaRpc,\n  devnet,\n  testnet,\n  mainnet,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcTestnet,\n  type SolanaRpcApiTestnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n} from \"@solana/kit\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport type { Network } from \"@x402/core/types\";\nimport {\n  SVM_ADDRESS_REGEX,\n  DEVNET_RPC_URL,\n  TESTNET_RPC_URL,\n  MAINNET_RPC_URL,\n  USDC_MAINNET_ADDRESS,\n  USDC_DEVNET_ADDRESS,\n  USDC_TESTNET_ADDRESS,\n  SOLANA_MAINNET_CAIP2,\n  SOLANA_DEVNET_CAIP2,\n  SOLANA_TESTNET_CAIP2,\n  V1_TO_V2_NETWORK_MAP,\n} from \"./constants\";\nimport type { ExactSvmPayloadV1 } from \"./types\";\n\n/**\n * Normalize network identifier to CAIP-2 format\n * Handles both V1 names (solana, solana-devnet) and V2 CAIP-2 format\n *\n * @param network - Network identifier (V1 or V2 format)\n * @returns CAIP-2 network identifier\n */\nexport function normalizeNetwork(network: Network): string {\n  // If it's already CAIP-2 format (contains \":\"), validate it's supported\n  if (network.includes(\":\")) {\n    const supported = [SOLANA_MAINNET_CAIP2, SOLANA_DEVNET_CAIP2, SOLANA_TESTNET_CAIP2];\n    if (!supported.includes(network)) {\n      throw new Error(`Unsupported SVM network: ${network}`);\n    }\n    return network;\n  }\n\n  // Otherwise, it's a V1 network name, convert to CAIP-2\n  const caip2Network = V1_TO_V2_NETWORK_MAP[network];\n  if (!caip2Network) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return caip2Network;\n}\n\n/**\n * Validate Solana address format\n *\n * @param address - Base58 encoded address string\n * @returns true if address is valid, false otherwise\n */\nexport function validateSvmAddress(address: string): boolean {\n  return SVM_ADDRESS_REGEX.test(address);\n}\n\n/**\n * Decode a base64 encoded transaction from an SVM payload\n *\n * @param svmPayload - The SVM payload containing a base64 encoded transaction\n * @returns Decoded Transaction object\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayloadV1): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"Error decoding transaction:\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Extract the token sender (owner of the source token account) from a TransferChecked instruction\n *\n * @param transaction - The decoded transaction\n * @returns The token payer address as a base58 string\n */\nexport function getTokenPayerFromTransaction(transaction: Transaction): string {\n  const compiled = getCompiledTransactionMessageDecoder().decode(transaction.messageBytes);\n  const staticAccounts = compiled.staticAccounts ?? [];\n  const instructions = compiled.instructions ?? [];\n\n  for (const ix of instructions) {\n    const programIndex = ix.programAddressIndex;\n    const programAddress = staticAccounts[programIndex].toString();\n\n    // Check if this is a token program instruction\n    if (\n      programAddress === TOKEN_PROGRAM_ADDRESS.toString() ||\n      programAddress === TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      const accountIndices: number[] = ix.accountIndices ?? [];\n      // TransferChecked account order: [source, mint, destination, owner, ...]\n      if (accountIndices.length >= 4) {\n        const ownerIndex = accountIndices[3];\n        const ownerAddress = staticAccounts[ownerIndex].toString();\n        if (ownerAddress) return ownerAddress;\n      }\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * Create an RPC client for the specified network\n *\n * @param network - Network identifier (CAIP-2 or V1 format)\n * @param customRpcUrl - Optional custom RPC URL\n * @returns RPC client for the specified network\n */\nexport function createRpcClient(\n  network: Network,\n  customRpcUrl?: string,\n):\n  | RpcDevnet<SolanaRpcApiDevnet>\n  | RpcTestnet<SolanaRpcApiTestnet>\n  | RpcMainnet<SolanaRpcApiMainnet> {\n  const caip2Network = normalizeNetwork(network);\n\n  switch (caip2Network) {\n    case SOLANA_DEVNET_CAIP2: {\n      const url = customRpcUrl || DEVNET_RPC_URL;\n      return createSolanaRpc(devnet(url)) as RpcDevnet<SolanaRpcApiDevnet>;\n    }\n    case SOLANA_TESTNET_CAIP2: {\n      const url = customRpcUrl || TESTNET_RPC_URL;\n      return createSolanaRpc(testnet(url)) as RpcTestnet<SolanaRpcApiTestnet>;\n    }\n    case SOLANA_MAINNET_CAIP2: {\n      const url = customRpcUrl || MAINNET_RPC_URL;\n      return createSolanaRpc(mainnet(url)) as RpcMainnet<SolanaRpcApiMainnet>;\n    }\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n\n/**\n * Get the default USDC mint address for a network\n *\n * @param network - Network identifier (CAIP-2 or V1 format)\n * @returns USDC mint address for the network\n */\nexport function getUsdcAddress(network: Network): string {\n  const caip2Network = normalizeNetwork(network);\n\n  switch (caip2Network) {\n    case SOLANA_MAINNET_CAIP2:\n      return USDC_MAINNET_ADDRESS;\n    case SOLANA_DEVNET_CAIP2:\n      return USDC_DEVNET_ADDRESS;\n    case SOLANA_TESTNET_CAIP2:\n      return USDC_TESTNET_ADDRESS;\n    default:\n      throw new Error(`No USDC address configured for network: ${network}`);\n  }\n}\n\n/**\n * Convert a decimal amount to token smallest units\n *\n * @param decimalAmount - The decimal amount (e.g., \"0.10\")\n * @param decimals - The number of decimals for the token (e.g., 6 for USDC)\n * @returns The amount in smallest units as a string\n */\nexport function convertToTokenAmount(decimalAmount: string, decimals: number): string {\n  const amount = parseFloat(decimalAmount);\n  if (isNaN(amount)) {\n    throw new Error(`Invalid amount: ${decimalAmount}`);\n  }\n  // Convert to smallest unit (e.g., for USDC with 6 decimals: 0.10 * 10^6 = 100000)\n  const [intPart, decPart = \"\"] = String(amount).split(\".\");\n  const paddedDec = decPart.padEnd(decimals, \"0\").slice(0, decimals);\n  const tokenAmount = (intPart + paddedDec).replace(/^0+/, \"\") || \"0\";\n  return tokenAmount;\n}\n","import {\n  COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  parseSetComputeUnitLimitInstruction,\n  parseSetComputeUnitPriceInstruction,\n} from \"@solana-program/compute-budget\";\nimport {\n  parseTransferCheckedInstruction as parseTransferCheckedInstructionToken,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"@solana-program/token\";\nimport {\n  findAssociatedTokenPda,\n  parseTransferCheckedInstruction as parseTransferCheckedInstruction2022,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport {\n  decompileTransactionMessage,\n  getCompiledTransactionMessageDecoder,\n  type Address,\n} from \"@solana/kit\";\nimport type {\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkFacilitator,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport type { PaymentPayloadV1, PaymentRequirementsV1 } from \"@x402/core/types/v1\";\nimport { MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS } from \"../../../constants\";\nimport type { FacilitatorSvmSigner } from \"../../../signer\";\nimport type { ExactSvmPayloadV1 } from \"../../../types\";\nimport { decodeTransactionFromPayload, getTokenPayerFromTransaction } from \"../../../utils\";\n\n/**\n * SVM facilitator implementation for the Exact payment scheme (V1).\n */\nexport class ExactSvmSchemeV1 implements SchemeNetworkFacilitator {\n  readonly scheme = \"exact\";\n  readonly caipFamily = \"solana:*\";\n\n  /**\n   * Creates a new ExactSvmFacilitatorV1 instance.\n   *\n   * @param signer - The SVM RPC client for facilitator operations\n   * @returns ExactSvmFacilitatorV1 instance\n   */\n  constructor(private readonly signer: FacilitatorSvmSigner) {}\n\n  /**\n   * Get mechanism-specific extra data for the supported kinds endpoint.\n   * For SVM, this includes a randomly selected fee payer address.\n   * Random selection distributes load across multiple signers.\n   *\n   * @param _ - The network identifier (unused for SVM)\n   * @returns Extra data with feePayer address\n   */\n  getExtra(_: string): Record<string, unknown> | undefined {\n    // Randomly select from available signers to distribute load\n    const addresses = this.signer.getAddresses();\n    const randomIndex = Math.floor(Math.random() * addresses.length);\n\n    return {\n      feePayer: addresses[randomIndex],\n    };\n  }\n\n  /**\n   * Get signer addresses used by this facilitator.\n   * For SVM, returns all available fee payer addresses.\n   *\n   * @param _ - The network identifier (unused for SVM)\n   * @returns Array of fee payer addresses\n   */\n  getSigners(_: string): string[] {\n    return [...this.signer.getAddresses()];\n  }\n\n  /**\n   * Verifies a payment payload (V1).\n   *\n   * @param payload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to verification response\n   */\n  async verify(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const requirementsV1 = requirements as unknown as PaymentRequirementsV1;\n    const payloadV1 = payload as unknown as PaymentPayloadV1;\n    const exactSvmPayload = payload.payload as ExactSvmPayloadV1;\n\n    // Step 1: Validate Payment Requirements\n    if (payloadV1.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n      return {\n        isValid: false,\n        invalidReason: \"unsupported_scheme\",\n        payer: \"\",\n      };\n    }\n\n    if (payloadV1.network !== requirements.network) {\n      return {\n        isValid: false,\n        invalidReason: \"network_mismatch\",\n        payer: \"\",\n      };\n    }\n\n    if (!requirementsV1.extra?.feePayer || typeof requirementsV1.extra.feePayer !== \"string\") {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_missing_fee_payer\",\n        payer: \"\",\n      };\n    }\n\n    // Verify that the requested feePayer is managed by this facilitator\n    const signerAddresses = this.signer.getAddresses().map(addr => addr.toString());\n    if (!signerAddresses.includes(requirementsV1.extra.feePayer)) {\n      return {\n        isValid: false,\n        invalidReason: \"fee_payer_not_managed_by_facilitator\",\n        payer: \"\",\n      };\n    }\n\n    // Step 2: Parse and Validate Transaction Structure\n    let transaction;\n    try {\n      transaction = decodeTransactionFromPayload(exactSvmPayload);\n    } catch {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_transaction_could_not_be_decoded\",\n        payer: \"\",\n      };\n    }\n\n    const compiled = getCompiledTransactionMessageDecoder().decode(transaction.messageBytes);\n    const decompiled = decompileTransactionMessage(compiled);\n    const instructions = decompiled.instructions ?? [];\n\n    // 3 instructions: ComputeLimit + ComputePrice + TransferChecked\n    if (instructions.length !== 3) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_transaction_instructions_length\",\n        payer: \"\",\n      };\n    }\n\n    // Step 3: Verify Compute Budget Instructions\n    try {\n      this.verifyComputeLimitInstruction(instructions[0] as never);\n      this.verifyComputePriceInstruction(instructions[1] as never);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      return {\n        isValid: false,\n        invalidReason: errorMessage,\n        payer: \"\",\n      };\n    }\n\n    const payer = getTokenPayerFromTransaction(transaction);\n    if (!payer) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_no_transfer_instruction\",\n        payer: \"\",\n      };\n    }\n\n    // Step 4: Verify Transfer Instruction\n    const transferIx = instructions[2];\n    const programAddress = transferIx.programAddress.toString();\n\n    if (\n      programAddress !== TOKEN_PROGRAM_ADDRESS.toString() &&\n      programAddress !== TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_no_transfer_instruction\",\n        payer,\n      };\n    }\n\n    // Parse the transfer instruction using the appropriate library helper\n    let parsedTransfer;\n    try {\n      if (programAddress === TOKEN_PROGRAM_ADDRESS.toString()) {\n        parsedTransfer = parseTransferCheckedInstructionToken(transferIx as never);\n      } else {\n        parsedTransfer = parseTransferCheckedInstruction2022(transferIx as never);\n      }\n    } catch {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_no_transfer_instruction\",\n        payer,\n      };\n    }\n\n    // Verify that the facilitator's signers are not transferring their own funds\n    // SECURITY: Prevent facilitator from signing away their own tokens\n    const authorityAddress = parsedTransfer.accounts.authority.address.toString();\n    if (signerAddresses.includes(authorityAddress)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_transaction_fee_payer_transferring_funds\",\n        payer,\n      };\n    }\n\n    // Verify mint address matches requirements\n    const mintAddress = parsedTransfer.accounts.mint.address.toString();\n    if (mintAddress !== requirements.asset) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_mint_mismatch\",\n        payer,\n      };\n    }\n\n    // Verify destination ATA matches expected ATA for payTo address\n    const destATA = parsedTransfer.accounts.destination.address.toString();\n    try {\n      const [expectedDestATA] = await findAssociatedTokenPda({\n        mint: requirements.asset as Address,\n        owner: requirements.payTo as Address,\n        tokenProgram:\n          programAddress === TOKEN_PROGRAM_ADDRESS.toString()\n            ? (TOKEN_PROGRAM_ADDRESS as Address)\n            : (TOKEN_2022_PROGRAM_ADDRESS as Address),\n      });\n\n      if (destATA !== expectedDestATA.toString()) {\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_svm_payload_recipient_mismatch\",\n          payer,\n        };\n      }\n    } catch {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_recipient_mismatch\",\n        payer,\n      };\n    }\n\n    // Verify transfer amount meets requirements\n    const amount = parsedTransfer.data.amount;\n    if (amount < BigInt(requirementsV1.maxAmountRequired)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_svm_payload_amount_insufficient\",\n        payer,\n      };\n    }\n\n    // Step 5: Sign and Simulate Transaction\n    // CRITICAL: Simulation proves transaction will succeed (catches insufficient balance, invalid accounts, etc)\n    try {\n      const feePayer = requirementsV1.extra.feePayer as Address;\n\n      // Sign transaction with the feePayer's signer\n      const fullySignedTransaction = await this.signer.signTransaction(\n        exactSvmPayload.transaction,\n        feePayer,\n        requirements.network,\n      );\n\n      // Simulate to verify transaction would succeed\n      await this.signer.simulateTransaction(fullySignedTransaction, requirements.network);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      return {\n        isValid: false,\n        invalidReason: `transaction_simulation_failed: ${errorMessage}`,\n        payer,\n      };\n    }\n\n    return {\n      isValid: true,\n      invalidReason: undefined,\n      payer,\n    };\n  }\n\n  /**\n   * Settles a payment by submitting the transaction (V1).\n   * Ensures the correct signer is used based on the feePayer specified in requirements.\n   *\n   * @param payload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to settlement response\n   */\n  async settle(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const payloadV1 = payload as unknown as PaymentPayloadV1;\n    const exactSvmPayload = payload.payload as ExactSvmPayloadV1;\n\n    const valid = await this.verify(payload, requirements);\n    if (!valid.isValid) {\n      return {\n        success: false,\n        network: payloadV1.network,\n        transaction: \"\",\n        errorReason: valid.invalidReason ?? \"verification_failed\",\n        payer: valid.payer || \"\",\n      };\n    }\n\n    try {\n      // Extract feePayer from requirements (already validated in verify)\n      const feePayer = requirements.extra.feePayer as Address;\n\n      // Sign transaction with the feePayer's signer\n      const fullySignedTransaction = await this.signer.signTransaction(\n        exactSvmPayload.transaction,\n        feePayer,\n        requirements.network,\n      );\n\n      // Send transaction to network\n      const signature = await this.signer.sendTransaction(\n        fullySignedTransaction,\n        requirements.network,\n      );\n\n      // Wait for confirmation\n      await this.signer.confirmTransaction(signature, requirements.network);\n\n      return {\n        success: true,\n        transaction: signature,\n        network: payloadV1.network,\n        payer: valid.payer,\n      };\n    } catch (error) {\n      console.error(\"Failed to settle transaction:\", error);\n      return {\n        success: false,\n        errorReason: \"transaction_failed\",\n        transaction: \"\",\n        network: payloadV1.network,\n        payer: valid.payer || \"\",\n      };\n    }\n  }\n\n  /**\n   * Verify compute limit instruction\n   *\n   * @param instruction - The compute limit instruction\n   * @param instruction.programAddress - Program address\n   * @param instruction.data - Instruction data bytes\n   */\n  private verifyComputeLimitInstruction(instruction: {\n    programAddress: Address;\n    data?: Readonly<Uint8Array>;\n  }): void {\n    const programAddress = instruction.programAddress.toString();\n\n    if (\n      programAddress !== COMPUTE_BUDGET_PROGRAM_ADDRESS.toString() ||\n      !instruction.data ||\n      instruction.data[0] !== 2\n    ) {\n      throw new Error(\n        \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n      );\n    }\n\n    try {\n      parseSetComputeUnitLimitInstruction(instruction as never);\n    } catch {\n      throw new Error(\n        \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n      );\n    }\n  }\n\n  /**\n   * Verify compute price instruction\n   *\n   * @param instruction - The compute price instruction\n   * @param instruction.programAddress - Program address\n   * @param instruction.data - Instruction data bytes\n   */\n  private verifyComputePriceInstruction(instruction: {\n    programAddress: Address;\n    data?: Readonly<Uint8Array>;\n  }): void {\n    const programAddress = instruction.programAddress.toString();\n\n    if (\n      programAddress !== COMPUTE_BUDGET_PROGRAM_ADDRESS.toString() ||\n      !instruction.data ||\n      instruction.data[0] !== 3\n    ) {\n      throw new Error(\n        \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n      );\n    }\n\n    try {\n      const parsedInstruction = parseSetComputeUnitPriceInstruction(instruction as never);\n\n      // Check if price exceeds maximum (5 lamports per compute unit)\n      if (\n        (parsedInstruction as unknown as { microLamports: bigint }).microLamports >\n        BigInt(MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS)\n      ) {\n        throw new Error(\n          \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high\",\n        );\n      }\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(\"too_high\")) {\n        throw error;\n      }\n      throw new Error(\n        \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n      );\n    }\n  }\n}\n"],"mappings":"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","names":["import_token","import_token_2022","import_kit","tx","import_compute_budget","import_token","import_token_2022","import_kit"]}