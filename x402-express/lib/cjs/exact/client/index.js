"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/exact/client/index.ts
var client_exports = {};
__export(client_exports, {
  ExactSvmScheme: () => ExactSvmScheme,
  registerExactSvmScheme: () => registerExactSvmScheme
});
module.exports = __toCommonJS(client_exports);

// src/exact/client/scheme.ts
var import_compute_budget = require("@solana-program/compute-budget");
var import_token2 = require("@solana-program/token");
var import_token_20222 = require("@solana-program/token-2022");
var import_kit2 = require("@solana/kit");

// src/constants.ts
var DEVNET_RPC_URL = "https://api.devnet.solana.com";
var TESTNET_RPC_URL = "https://api.testnet.solana.com";
var MAINNET_RPC_URL = "https://api.mainnet-beta.solana.com";
var DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 1;
var DEFAULT_COMPUTE_UNIT_LIMIT = 6500;
var SOLANA_MAINNET_CAIP2 = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp";
var SOLANA_DEVNET_CAIP2 = "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1";
var SOLANA_TESTNET_CAIP2 = "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z";
var V1_TO_V2_NETWORK_MAP = {
  solana: SOLANA_MAINNET_CAIP2,
  "solana-devnet": SOLANA_DEVNET_CAIP2,
  "solana-testnet": SOLANA_TESTNET_CAIP2
};

// src/utils.ts
var import_kit = require("@solana/kit");
var import_token = require("@solana-program/token");
var import_token_2022 = require("@solana-program/token-2022");
function normalizeNetwork(network) {
  if (network.includes(":")) {
    const supported = [SOLANA_MAINNET_CAIP2, SOLANA_DEVNET_CAIP2, SOLANA_TESTNET_CAIP2];
    if (!supported.includes(network)) {
      throw new Error(`Unsupported SVM network: ${network}`);
    }
    return network;
  }
  const caip2Network = V1_TO_V2_NETWORK_MAP[network];
  if (!caip2Network) {
    throw new Error(`Unsupported SVM network: ${network}`);
  }
  return caip2Network;
}
function createRpcClient(network, customRpcUrl) {
  const caip2Network = normalizeNetwork(network);
  switch (caip2Network) {
    case SOLANA_DEVNET_CAIP2: {
      const url = customRpcUrl || DEVNET_RPC_URL;
      return (0, import_kit.createSolanaRpc)((0, import_kit.devnet)(url));
    }
    case SOLANA_TESTNET_CAIP2: {
      const url = customRpcUrl || TESTNET_RPC_URL;
      return (0, import_kit.createSolanaRpc)((0, import_kit.testnet)(url));
    }
    case SOLANA_MAINNET_CAIP2: {
      const url = customRpcUrl || MAINNET_RPC_URL;
      return (0, import_kit.createSolanaRpc)((0, import_kit.mainnet)(url));
    }
    default:
      throw new Error(`Unsupported network: ${network}`);
  }
}

// src/exact/client/scheme.ts
var ExactSvmScheme = class {
  /**
   * Creates a new ExactSvmClient instance.
   *
   * @param signer - The SVM signer for client operations
   * @param config - Optional configuration with custom RPC URL
   * @returns ExactSvmClient instance
   */
  constructor(signer, config) {
    this.signer = signer;
    this.config = config;
    this.scheme = "exact";
  }
  /**
   * Creates a payment payload for the Exact scheme.
   *
   * @param x402Version - The x402 protocol version
   * @param paymentRequirements - The payment requirements
   * @returns Promise resolving to a payment payload
   */
  async createPaymentPayload(x402Version, paymentRequirements) {
    const rpc = createRpcClient(paymentRequirements.network, this.config?.rpcUrl);
    const tokenMint = await (0, import_token_20222.fetchMint)(rpc, paymentRequirements.asset);
    const tokenProgramAddress = tokenMint.programAddress;
    if (tokenProgramAddress.toString() !== import_token2.TOKEN_PROGRAM_ADDRESS.toString() && tokenProgramAddress.toString() !== import_token_20222.TOKEN_2022_PROGRAM_ADDRESS.toString()) {
      throw new Error("Asset was not created by a known token program");
    }
    const [sourceATA] = await (0, import_token_20222.findAssociatedTokenPda)({
      mint: paymentRequirements.asset,
      owner: this.signer.address,
      tokenProgram: tokenProgramAddress
    });
    const [destinationATA] = await (0, import_token_20222.findAssociatedTokenPda)({
      mint: paymentRequirements.asset,
      owner: paymentRequirements.payTo,
      tokenProgram: tokenProgramAddress
    });
    const transferIx = (0, import_token_20222.getTransferCheckedInstruction)(
      {
        source: sourceATA,
        mint: paymentRequirements.asset,
        destination: destinationATA,
        authority: this.signer,
        amount: BigInt(paymentRequirements.amount),
        decimals: tokenMint.data.decimals
      },
      { programAddress: tokenProgramAddress }
    );
    const feePayer = paymentRequirements.extra?.feePayer;
    if (!feePayer) {
      throw new Error("feePayer is required in paymentRequirements.extra for SVM transactions");
    }
    const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();
    const tx = (0, import_kit2.pipe)(
      (0, import_kit2.createTransactionMessage)({ version: 0 }),
      (tx2) => (0, import_compute_budget.setTransactionMessageComputeUnitPrice)(DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS, tx2),
      (tx2) => (0, import_kit2.setTransactionMessageFeePayer)(feePayer, tx2),
      (tx2) => (0, import_kit2.prependTransactionMessageInstruction)(
        (0, import_compute_budget.getSetComputeUnitLimitInstruction)({ units: DEFAULT_COMPUTE_UNIT_LIMIT }),
        tx2
      ),
      (tx2) => (0, import_kit2.appendTransactionMessageInstructions)([transferIx], tx2),
      (tx2) => (0, import_kit2.setTransactionMessageLifetimeUsingBlockhash)(latestBlockhash, tx2)
    );
    const signedTransaction = await (0, import_kit2.partiallySignTransactionMessageWithSigners)(tx);
    const base64EncodedWireTransaction = (0, import_kit2.getBase64EncodedWireTransaction)(signedTransaction);
    const payload = {
      transaction: base64EncodedWireTransaction
    };
    return {
      x402Version,
      payload
    };
  }
};

// src/exact/v1/client/scheme.ts
var import_compute_budget2 = require("@solana-program/compute-budget");
var import_token3 = require("@solana-program/token");
var import_token_20223 = require("@solana-program/token-2022");
var import_kit3 = require("@solana/kit");
var ExactSvmSchemeV1 = class {
  /**
   * Creates a new ExactSvmClientV1 instance.
   *
   * @param signer - The SVM signer for client operations
   * @param config - Optional configuration with custom RPC URL
   * @returns ExactSvmClientV1 instance
   */
  constructor(signer, config) {
    this.signer = signer;
    this.config = config;
    this.scheme = "exact";
  }
  /**
   * Creates a payment payload for the Exact scheme (V1).
   *
   * @param x402Version - The x402 protocol version
   * @param paymentRequirements - The payment requirements
   * @returns Promise resolving to a payment payload
   */
  async createPaymentPayload(x402Version, paymentRequirements) {
    const selectedV1 = paymentRequirements;
    const rpc = createRpcClient(selectedV1.network, this.config?.rpcUrl);
    const tokenMint = await (0, import_token_20223.fetchMint)(rpc, selectedV1.asset);
    const tokenProgramAddress = tokenMint.programAddress;
    if (tokenProgramAddress.toString() !== import_token3.TOKEN_PROGRAM_ADDRESS.toString() && tokenProgramAddress.toString() !== import_token_20223.TOKEN_2022_PROGRAM_ADDRESS.toString()) {
      throw new Error("Asset was not created by a known token program");
    }
    const [sourceATA] = await (0, import_token_20223.findAssociatedTokenPda)({
      mint: selectedV1.asset,
      owner: this.signer.address,
      tokenProgram: tokenProgramAddress
    });
    const [destinationATA] = await (0, import_token_20223.findAssociatedTokenPda)({
      mint: selectedV1.asset,
      owner: selectedV1.payTo,
      tokenProgram: tokenProgramAddress
    });
    const transferIx = (0, import_token_20223.getTransferCheckedInstruction)(
      {
        source: sourceATA,
        mint: selectedV1.asset,
        destination: destinationATA,
        authority: this.signer,
        amount: BigInt(selectedV1.maxAmountRequired),
        decimals: tokenMint.data.decimals
      },
      { programAddress: tokenProgramAddress }
    );
    const feePayer = selectedV1.extra?.feePayer;
    if (!feePayer) {
      throw new Error("feePayer is required in paymentRequirements.extra for SVM transactions");
    }
    const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();
    const tx = (0, import_kit3.pipe)(
      (0, import_kit3.createTransactionMessage)({ version: 0 }),
      (tx2) => (0, import_compute_budget2.setTransactionMessageComputeUnitPrice)(DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS, tx2),
      (tx2) => (0, import_kit3.setTransactionMessageFeePayer)(feePayer, tx2),
      (tx2) => (0, import_kit3.prependTransactionMessageInstruction)(
        (0, import_compute_budget2.getSetComputeUnitLimitInstruction)({ units: DEFAULT_COMPUTE_UNIT_LIMIT }),
        tx2
      ),
      (tx2) => (0, import_kit3.appendTransactionMessageInstructions)([transferIx], tx2),
      (tx2) => (0, import_kit3.setTransactionMessageLifetimeUsingBlockhash)(latestBlockhash, tx2)
    );
    const signedTransaction = await (0, import_kit3.partiallySignTransactionMessageWithSigners)(tx);
    const base64EncodedWireTransaction = (0, import_kit3.getBase64EncodedWireTransaction)(signedTransaction);
    const payload = {
      transaction: base64EncodedWireTransaction
    };
    return {
      x402Version,
      scheme: selectedV1.scheme,
      network: selectedV1.network,
      payload
    };
  }
};

// src/exact/v1/facilitator/scheme.ts
var import_compute_budget3 = require("@solana-program/compute-budget");
var import_token4 = require("@solana-program/token");
var import_token_20224 = require("@solana-program/token-2022");
var import_kit4 = require("@solana/kit");

// src/v1/index.ts
var NETWORKS = ["solana", "solana-devnet", "solana-testnet"];

// src/exact/client/register.ts
function registerExactSvmScheme(client, config) {
  if (config.networks && config.networks.length > 0) {
    config.networks.forEach((network) => {
      client.register(network, new ExactSvmScheme(config.signer));
    });
  } else {
    client.register("solana:*", new ExactSvmScheme(config.signer));
  }
  NETWORKS.forEach((network) => {
    client.registerV1(network, new ExactSvmSchemeV1(config.signer));
  });
  if (config.policies) {
    config.policies.forEach((policy) => {
      client.registerPolicy(policy);
    });
  }
  return client;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExactSvmScheme,
  registerExactSvmScheme
});
//# sourceMappingURL=index.js.map