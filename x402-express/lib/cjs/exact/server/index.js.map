{"version":3,"sources":["../../../../src/exact/server/index.ts","../../../../src/utils.ts","../../../../src/constants.ts","../../../../src/exact/server/scheme.ts","../../../../src/exact/server/register.ts"],"sourcesContent":["export { ExactSvmScheme } from \"./scheme\";\nexport { registerExactSvmScheme } from \"./register\";\nexport type { SvmResourceServerConfig } from \"./register\";\n","import {\n  getBase64Encoder,\n  getTransactionDecoder,\n  getCompiledTransactionMessageDecoder,\n  type Transaction,\n  createSolanaRpc,\n  devnet,\n  testnet,\n  mainnet,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcTestnet,\n  type SolanaRpcApiTestnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n} from \"@solana/kit\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport type { Network } from \"@x402/core/types\";\nimport {\n  SVM_ADDRESS_REGEX,\n  DEVNET_RPC_URL,\n  TESTNET_RPC_URL,\n  MAINNET_RPC_URL,\n  USDC_MAINNET_ADDRESS,\n  USDC_DEVNET_ADDRESS,\n  USDC_TESTNET_ADDRESS,\n  SOLANA_MAINNET_CAIP2,\n  SOLANA_DEVNET_CAIP2,\n  SOLANA_TESTNET_CAIP2,\n  V1_TO_V2_NETWORK_MAP,\n} from \"./constants\";\nimport type { ExactSvmPayloadV1 } from \"./types\";\n\n/**\n * Normalize network identifier to CAIP-2 format\n * Handles both V1 names (solana, solana-devnet) and V2 CAIP-2 format\n *\n * @param network - Network identifier (V1 or V2 format)\n * @returns CAIP-2 network identifier\n */\nexport function normalizeNetwork(network: Network): string {\n  // If it's already CAIP-2 format (contains \":\"), validate it's supported\n  if (network.includes(\":\")) {\n    const supported = [SOLANA_MAINNET_CAIP2, SOLANA_DEVNET_CAIP2, SOLANA_TESTNET_CAIP2];\n    if (!supported.includes(network)) {\n      throw new Error(`Unsupported SVM network: ${network}`);\n    }\n    return network;\n  }\n\n  // Otherwise, it's a V1 network name, convert to CAIP-2\n  const caip2Network = V1_TO_V2_NETWORK_MAP[network];\n  if (!caip2Network) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return caip2Network;\n}\n\n/**\n * Validate Solana address format\n *\n * @param address - Base58 encoded address string\n * @returns true if address is valid, false otherwise\n */\nexport function validateSvmAddress(address: string): boolean {\n  return SVM_ADDRESS_REGEX.test(address);\n}\n\n/**\n * Decode a base64 encoded transaction from an SVM payload\n *\n * @param svmPayload - The SVM payload containing a base64 encoded transaction\n * @returns Decoded Transaction object\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayloadV1): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"Error decoding transaction:\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Extract the token sender (owner of the source token account) from a TransferChecked instruction\n *\n * @param transaction - The decoded transaction\n * @returns The token payer address as a base58 string\n */\nexport function getTokenPayerFromTransaction(transaction: Transaction): string {\n  const compiled = getCompiledTransactionMessageDecoder().decode(transaction.messageBytes);\n  const staticAccounts = compiled.staticAccounts ?? [];\n  const instructions = compiled.instructions ?? [];\n\n  for (const ix of instructions) {\n    const programIndex = ix.programAddressIndex;\n    const programAddress = staticAccounts[programIndex].toString();\n\n    // Check if this is a token program instruction\n    if (\n      programAddress === TOKEN_PROGRAM_ADDRESS.toString() ||\n      programAddress === TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      const accountIndices: number[] = ix.accountIndices ?? [];\n      // TransferChecked account order: [source, mint, destination, owner, ...]\n      if (accountIndices.length >= 4) {\n        const ownerIndex = accountIndices[3];\n        const ownerAddress = staticAccounts[ownerIndex].toString();\n        if (ownerAddress) return ownerAddress;\n      }\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * Create an RPC client for the specified network\n *\n * @param network - Network identifier (CAIP-2 or V1 format)\n * @param customRpcUrl - Optional custom RPC URL\n * @returns RPC client for the specified network\n */\nexport function createRpcClient(\n  network: Network,\n  customRpcUrl?: string,\n):\n  | RpcDevnet<SolanaRpcApiDevnet>\n  | RpcTestnet<SolanaRpcApiTestnet>\n  | RpcMainnet<SolanaRpcApiMainnet> {\n  const caip2Network = normalizeNetwork(network);\n\n  switch (caip2Network) {\n    case SOLANA_DEVNET_CAIP2: {\n      const url = customRpcUrl || DEVNET_RPC_URL;\n      return createSolanaRpc(devnet(url)) as RpcDevnet<SolanaRpcApiDevnet>;\n    }\n    case SOLANA_TESTNET_CAIP2: {\n      const url = customRpcUrl || TESTNET_RPC_URL;\n      return createSolanaRpc(testnet(url)) as RpcTestnet<SolanaRpcApiTestnet>;\n    }\n    case SOLANA_MAINNET_CAIP2: {\n      const url = customRpcUrl || MAINNET_RPC_URL;\n      return createSolanaRpc(mainnet(url)) as RpcMainnet<SolanaRpcApiMainnet>;\n    }\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n\n/**\n * Get the default USDC mint address for a network\n *\n * @param network - Network identifier (CAIP-2 or V1 format)\n * @returns USDC mint address for the network\n */\nexport function getUsdcAddress(network: Network): string {\n  const caip2Network = normalizeNetwork(network);\n\n  switch (caip2Network) {\n    case SOLANA_MAINNET_CAIP2:\n      return USDC_MAINNET_ADDRESS;\n    case SOLANA_DEVNET_CAIP2:\n      return USDC_DEVNET_ADDRESS;\n    case SOLANA_TESTNET_CAIP2:\n      return USDC_TESTNET_ADDRESS;\n    default:\n      throw new Error(`No USDC address configured for network: ${network}`);\n  }\n}\n\n/**\n * Convert a decimal amount to token smallest units\n *\n * @param decimalAmount - The decimal amount (e.g., \"0.10\")\n * @param decimals - The number of decimals for the token (e.g., 6 for USDC)\n * @returns The amount in smallest units as a string\n */\nexport function convertToTokenAmount(decimalAmount: string, decimals: number): string {\n  const amount = parseFloat(decimalAmount);\n  if (isNaN(amount)) {\n    throw new Error(`Invalid amount: ${decimalAmount}`);\n  }\n  // Convert to smallest unit (e.g., for USDC with 6 decimals: 0.10 * 10^6 = 100000)\n  const [intPart, decPart = \"\"] = String(amount).split(\".\");\n  const paddedDec = decPart.padEnd(decimals, \"0\").slice(0, decimals);\n  const tokenAmount = (intPart + paddedDec).replace(/^0+/, \"\") || \"0\";\n  return tokenAmount;\n}\n","/**\n * Token program addresses for SPL Token and Token-2022\n * These addresses are the same across all Solana networks (mainnet, devnet, testnet)\n */\nexport const TOKEN_PROGRAM_ADDRESS = \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\nexport const TOKEN_2022_PROGRAM_ADDRESS = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\nexport const COMPUTE_BUDGET_PROGRAM_ADDRESS = \"ComputeBudget111111111111111111111111111111\";\n\n/**\n * Default RPC URLs for Solana networks\n */\nexport const DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\nexport const TESTNET_RPC_URL = \"https://api.testnet.solana.com\";\nexport const MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\nexport const DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\nexport const TESTNET_WS_URL = \"wss://api.testnet.solana.com\";\nexport const MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\n\n/**\n * USDC token mint addresses (default stablecoin)\n */\nexport const USDC_MAINNET_ADDRESS = \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\";\nexport const USDC_DEVNET_ADDRESS = \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\";\nexport const USDC_TESTNET_ADDRESS = \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\"; // Same as devnet\n\n/**\n * Compute budget configuration\n * All prices are in microlamports (1 lamport = 1,000,000 microlamports)\n */\nexport const DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 1;\nexport const MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 5_000_000; // 5 lamports\nexport const DEFAULT_COMPUTE_UNIT_LIMIT = 6500;\n\n/**\n * Solana address validation regex (base58, 32-44 characters)\n */\nexport const SVM_ADDRESS_REGEX = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n\n/**\n * CAIP-2 network identifiers for Solana (V2)\n */\nexport const SOLANA_MAINNET_CAIP2 = \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\";\nexport const SOLANA_DEVNET_CAIP2 = \"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1\";\nexport const SOLANA_TESTNET_CAIP2 = \"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z\";\n\n/**\n * V1 to V2 network identifier mappings (for backwards compatibility)\n * V1 used simple names like solana, V2 uses CAIP-2\n */\nexport const V1_TO_V2_NETWORK_MAP: Record<string, string> = {\n  solana: SOLANA_MAINNET_CAIP2,\n  \"solana-devnet\": SOLANA_DEVNET_CAIP2,\n  \"solana-testnet\": SOLANA_TESTNET_CAIP2,\n};\n","import type {\n  AssetAmount,\n  Network,\n  PaymentRequirements,\n  Price,\n  SchemeNetworkServer,\n  MoneyParser,\n} from \"@x402/core/types\";\nimport { convertToTokenAmount, getUsdcAddress } from \"../../utils\";\n\n/**\n * SVM server implementation for the Exact payment scheme.\n */\nexport class ExactSvmScheme implements SchemeNetworkServer {\n  readonly scheme = \"exact\";\n  private moneyParsers: MoneyParser[] = [];\n\n  /**\n   * Register a custom money parser in the parser chain.\n   * Multiple parsers can be registered - they will be tried in registration order.\n   * Each parser receives a decimal amount (e.g., 1.50 for $1.50).\n   * If a parser returns null, the next parser in the chain will be tried.\n   * The default parser is always the final fallback.\n   *\n   * @param parser - Custom function to convert amount to AssetAmount (or null to skip)\n   * @returns The service instance for chaining\n   */\n  registerMoneyParser(parser: MoneyParser): ExactSvmScheme {\n    this.moneyParsers.push(parser);\n    return this;\n  }\n\n  /**\n   * Parses a price into an asset amount.\n   * If price is already an AssetAmount, returns it directly.\n   * If price is Money (string | number), parses to decimal and tries custom parsers.\n   * Falls back to default conversion if all custom parsers return null.\n   *\n   * @param price - The price to parse\n   * @param network - The network to use\n   * @returns Promise that resolves to the parsed asset amount\n   */\n  async parsePrice(price: Price, network: Network): Promise<AssetAmount> {\n    // If already an AssetAmount, return it directly\n    if (typeof price === \"object\" && price !== null && \"amount\" in price) {\n      if (!price.asset) {\n        throw new Error(`Asset address must be specified for AssetAmount on network ${network}`);\n      }\n      return {\n        amount: price.amount,\n        asset: price.asset,\n        extra: price.extra || {},\n      };\n    }\n\n    // Parse Money to decimal number\n    const amount = this.parseMoneyToDecimal(price);\n\n    // Try each custom money parser in order\n    for (const parser of this.moneyParsers) {\n      const result = await parser(amount, network);\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    // All custom parsers returned null, use default conversion\n    return this.defaultMoneyConversion(amount, network);\n  }\n\n  /**\n   * Build payment requirements for this scheme/network combination\n   *\n   * @param paymentRequirements - The base payment requirements\n   * @param supportedKind - The supported kind configuration\n   * @param supportedKind.x402Version - The x402 protocol version\n   * @param supportedKind.scheme - The payment scheme\n   * @param supportedKind.network - The network identifier\n   * @param supportedKind.extra - Extra metadata including feePayer address\n   * @param extensionKeys - Extension keys supported by the facilitator\n   * @returns Enhanced payment requirements with feePayer in extra\n   */\n  enhancePaymentRequirements(\n    paymentRequirements: PaymentRequirements,\n    supportedKind: {\n      x402Version: number;\n      scheme: string;\n      network: Network;\n      extra?: Record<string, unknown>;\n    },\n    extensionKeys: string[],\n  ): Promise<PaymentRequirements> {\n    // Mark unused parameters to satisfy linter\n    void extensionKeys;\n\n    // Add feePayer from supportedKind.extra to payment requirements\n    // The facilitator provides its address as the fee payer for transaction fees\n    return Promise.resolve({\n      ...paymentRequirements,\n      extra: {\n        ...paymentRequirements.extra,\n        feePayer: supportedKind.extra?.feePayer,\n      },\n    });\n  }\n\n  /**\n   * Parse Money (string | number) to a decimal number.\n   * Handles formats like \"$1.50\", \"1.50\", 1.50, etc.\n   *\n   * @param money - The money value to parse\n   * @returns Decimal number\n   */\n  private parseMoneyToDecimal(money: string | number): number {\n    if (typeof money === \"number\") {\n      return money;\n    }\n\n    // Remove $ sign and whitespace, then parse\n    const cleanMoney = money.replace(/^\\$/, \"\").trim();\n    const amount = parseFloat(cleanMoney);\n\n    if (isNaN(amount)) {\n      throw new Error(`Invalid money format: ${money}`);\n    }\n\n    return amount;\n  }\n\n  /**\n   * Default money conversion implementation.\n   * Converts decimal amount to USDC on the specified network.\n   *\n   * @param amount - The decimal amount (e.g., 1.50)\n   * @param network - The network to use\n   * @returns The parsed asset amount in USDC\n   */\n  private defaultMoneyConversion(amount: number, network: Network): AssetAmount {\n    // Convert decimal amount to token amount (USDC has 6 decimals)\n    const tokenAmount = convertToTokenAmount(amount.toString(), 6);\n\n    return {\n      amount: tokenAmount,\n      asset: getUsdcAddress(network),\n      extra: {},\n    };\n  }\n}\n","import { x402ResourceServer } from \"@x402/core/server\";\nimport { Network } from \"@x402/core/types\";\nimport { ExactSvmScheme } from \"./scheme\";\n\n/**\n * Configuration options for registering SVM schemes to an x402ResourceServer\n */\nexport interface SvmResourceServerConfig {\n  /**\n   * Optional specific networks to register\n   */\n  networks?: Network[];\n}\n\n/**\n * Registers SVM payment schemes to an existing x402ResourceServer instance.\n *\n * @param server - The x402ResourceServer instance to register schemes to\n * @param config - Configuration for SVM resource server registration\n * @returns The server instance for chaining\n */\nexport function registerExactSvmScheme(\n  server: x402ResourceServer,\n  config: SvmResourceServerConfig = {},\n): x402ResourceServer {\n  if (config.networks && config.networks.length > 0) {\n    config.networks.forEach(network => {\n      server.register(network, new ExactSvmScheme());\n    });\n  } else {\n    server.register(\"solana:*\", new ExactSvmScheme());\n  }\n\n  return server;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,iBAeO;AACP,mBAAsC;AACtC,wBAA2C;;;ACIpC,IAAM,uBAAuB;AAC7B,IAAM,sBAAsB;AAC5B,IAAM,uBAAuB;AAkB7B,IAAM,uBAAuB;AAC7B,IAAM,sBAAsB;AAC5B,IAAM,uBAAuB;AAM7B,IAAM,uBAA+C;AAAA,EAC1D,QAAQ;AAAA,EACR,iBAAiB;AAAA,EACjB,kBAAkB;AACpB;;;ADZO,SAAS,iBAAiB,SAA0B;AAEzD,MAAI,QAAQ,SAAS,GAAG,GAAG;AACzB,UAAM,YAAY,CAAC,sBAAsB,qBAAqB,oBAAoB;AAClF,QAAI,CAAC,UAAU,SAAS,OAAO,GAAG;AAChC,YAAM,IAAI,MAAM,4BAA4B,OAAO,EAAE;AAAA,IACvD;AACA,WAAO;AAAA,EACT;AAGA,QAAM,eAAe,qBAAqB,OAAO;AACjD,MAAI,CAAC,cAAc;AACjB,UAAM,IAAI,MAAM,4BAA4B,OAAO,EAAE;AAAA,EACvD;AACA,SAAO;AACT;AAuGO,SAAS,eAAe,SAA0B;AACvD,QAAM,eAAe,iBAAiB,OAAO;AAE7C,UAAQ,cAAc;AAAA,IACpB,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,YAAM,IAAI,MAAM,2CAA2C,OAAO,EAAE;AAAA,EACxE;AACF;AASO,SAAS,qBAAqB,eAAuB,UAA0B;AACpF,QAAM,SAAS,WAAW,aAAa;AACvC,MAAI,MAAM,MAAM,GAAG;AACjB,UAAM,IAAI,MAAM,mBAAmB,aAAa,EAAE;AAAA,EACpD;AAEA,QAAM,CAAC,SAAS,UAAU,EAAE,IAAI,OAAO,MAAM,EAAE,MAAM,GAAG;AACxD,QAAM,YAAY,QAAQ,OAAO,UAAU,GAAG,EAAE,MAAM,GAAG,QAAQ;AACjE,QAAM,eAAe,UAAU,WAAW,QAAQ,OAAO,EAAE,KAAK;AAChE,SAAO;AACT;;;AEnLO,IAAM,iBAAN,MAAoD;AAAA,EAApD;AACL,SAAS,SAAS;AAClB,SAAQ,eAA8B,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYvC,oBAAoB,QAAqC;AACvD,SAAK,aAAa,KAAK,MAAM;AAC7B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,WAAW,OAAc,SAAwC;AAErE,QAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,YAAY,OAAO;AACpE,UAAI,CAAC,MAAM,OAAO;AAChB,cAAM,IAAI,MAAM,8DAA8D,OAAO,EAAE;AAAA,MACzF;AACA,aAAO;AAAA,QACL,QAAQ,MAAM;AAAA,QACd,OAAO,MAAM;AAAA,QACb,OAAO,MAAM,SAAS,CAAC;AAAA,MACzB;AAAA,IACF;AAGA,UAAM,SAAS,KAAK,oBAAoB,KAAK;AAG7C,eAAW,UAAU,KAAK,cAAc;AACtC,YAAM,SAAS,MAAM,OAAO,QAAQ,OAAO;AAC3C,UAAI,WAAW,MAAM;AACnB,eAAO;AAAA,MACT;AAAA,IACF;AAGA,WAAO,KAAK,uBAAuB,QAAQ,OAAO;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,2BACE,qBACA,eAMA,eAC8B;AAE9B,SAAK;AAIL,WAAO,QAAQ,QAAQ;AAAA,MACrB,GAAG;AAAA,MACH,OAAO;AAAA,QACL,GAAG,oBAAoB;AAAA,QACvB,UAAU,cAAc,OAAO;AAAA,MACjC;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,oBAAoB,OAAgC;AAC1D,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO;AAAA,IACT;AAGA,UAAM,aAAa,MAAM,QAAQ,OAAO,EAAE,EAAE,KAAK;AACjD,UAAM,SAAS,WAAW,UAAU;AAEpC,QAAI,MAAM,MAAM,GAAG;AACjB,YAAM,IAAI,MAAM,yBAAyB,KAAK,EAAE;AAAA,IAClD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUQ,uBAAuB,QAAgB,SAA+B;AAE5E,UAAM,cAAc,qBAAqB,OAAO,SAAS,GAAG,CAAC;AAE7D,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,OAAO,eAAe,OAAO;AAAA,MAC7B,OAAO,CAAC;AAAA,IACV;AAAA,EACF;AACF;;;AC9HO,SAAS,uBACd,QACA,SAAkC,CAAC,GACf;AACpB,MAAI,OAAO,YAAY,OAAO,SAAS,SAAS,GAAG;AACjD,WAAO,SAAS,QAAQ,aAAW;AACjC,aAAO,SAAS,SAAS,IAAI,eAAe,CAAC;AAAA,IAC/C,CAAC;AAAA,EACH,OAAO;AACL,WAAO,SAAS,YAAY,IAAI,eAAe,CAAC;AAAA,EAClD;AAEA,SAAO;AACT;","names":[]}