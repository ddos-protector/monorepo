"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/exact/v1/facilitator/index.ts
var facilitator_exports = {};
__export(facilitator_exports, {
  ExactSvmSchemeV1: () => ExactSvmSchemeV1
});
module.exports = __toCommonJS(facilitator_exports);

// src/exact/v1/facilitator/scheme.ts
var import_compute_budget = require("@solana-program/compute-budget");
var import_token2 = require("@solana-program/token");
var import_token_20222 = require("@solana-program/token-2022");
var import_kit2 = require("@solana/kit");

// src/constants.ts
var MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 5e6;

// src/utils.ts
var import_kit = require("@solana/kit");
var import_token = require("@solana-program/token");
var import_token_2022 = require("@solana-program/token-2022");
function decodeTransactionFromPayload(svmPayload) {
  try {
    const base64Encoder = (0, import_kit.getBase64Encoder)();
    const transactionBytes = base64Encoder.encode(svmPayload.transaction);
    const transactionDecoder = (0, import_kit.getTransactionDecoder)();
    return transactionDecoder.decode(transactionBytes);
  } catch (error) {
    console.error("Error decoding transaction:", error);
    throw new Error("invalid_exact_svm_payload_transaction");
  }
}
function getTokenPayerFromTransaction(transaction) {
  const compiled = (0, import_kit.getCompiledTransactionMessageDecoder)().decode(transaction.messageBytes);
  const staticAccounts = compiled.staticAccounts ?? [];
  const instructions = compiled.instructions ?? [];
  for (const ix of instructions) {
    const programIndex = ix.programAddressIndex;
    const programAddress = staticAccounts[programIndex].toString();
    if (programAddress === import_token.TOKEN_PROGRAM_ADDRESS.toString() || programAddress === import_token_2022.TOKEN_2022_PROGRAM_ADDRESS.toString()) {
      const accountIndices = ix.accountIndices ?? [];
      if (accountIndices.length >= 4) {
        const ownerIndex = accountIndices[3];
        const ownerAddress = staticAccounts[ownerIndex].toString();
        if (ownerAddress) return ownerAddress;
      }
    }
  }
  return "";
}

// src/exact/v1/facilitator/scheme.ts
var ExactSvmSchemeV1 = class {
  /**
   * Creates a new ExactSvmFacilitatorV1 instance.
   *
   * @param signer - The SVM RPC client for facilitator operations
   * @returns ExactSvmFacilitatorV1 instance
   */
  constructor(signer) {
    this.signer = signer;
    this.scheme = "exact";
    this.caipFamily = "solana:*";
  }
  /**
   * Get mechanism-specific extra data for the supported kinds endpoint.
   * For SVM, this includes a randomly selected fee payer address.
   * Random selection distributes load across multiple signers.
   *
   * @param _ - The network identifier (unused for SVM)
   * @returns Extra data with feePayer address
   */
  getExtra(_) {
    const addresses = this.signer.getAddresses();
    const randomIndex = Math.floor(Math.random() * addresses.length);
    return {
      feePayer: addresses[randomIndex]
    };
  }
  /**
   * Get signer addresses used by this facilitator.
   * For SVM, returns all available fee payer addresses.
   *
   * @param _ - The network identifier (unused for SVM)
   * @returns Array of fee payer addresses
   */
  getSigners(_) {
    return [...this.signer.getAddresses()];
  }
  /**
   * Verifies a payment payload (V1).
   *
   * @param payload - The payment payload to verify
   * @param requirements - The payment requirements
   * @returns Promise resolving to verification response
   */
  async verify(payload, requirements) {
    const requirementsV1 = requirements;
    const payloadV1 = payload;
    const exactSvmPayload = payload.payload;
    if (payloadV1.scheme !== "exact" || requirements.scheme !== "exact") {
      return {
        isValid: false,
        invalidReason: "unsupported_scheme",
        payer: ""
      };
    }
    if (payloadV1.network !== requirements.network) {
      return {
        isValid: false,
        invalidReason: "network_mismatch",
        payer: ""
      };
    }
    if (!requirementsV1.extra?.feePayer || typeof requirementsV1.extra.feePayer !== "string") {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_missing_fee_payer",
        payer: ""
      };
    }
    const signerAddresses = this.signer.getAddresses().map((addr) => addr.toString());
    if (!signerAddresses.includes(requirementsV1.extra.feePayer)) {
      return {
        isValid: false,
        invalidReason: "fee_payer_not_managed_by_facilitator",
        payer: ""
      };
    }
    let transaction;
    try {
      transaction = decodeTransactionFromPayload(exactSvmPayload);
    } catch {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_transaction_could_not_be_decoded",
        payer: ""
      };
    }
    const compiled = (0, import_kit2.getCompiledTransactionMessageDecoder)().decode(transaction.messageBytes);
    const decompiled = (0, import_kit2.decompileTransactionMessage)(compiled);
    const instructions = decompiled.instructions ?? [];
    if (instructions.length !== 3) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_transaction_instructions_length",
        payer: ""
      };
    }
    try {
      this.verifyComputeLimitInstruction(instructions[0]);
      this.verifyComputePriceInstruction(instructions[1]);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        isValid: false,
        invalidReason: errorMessage,
        payer: ""
      };
    }
    const payer = getTokenPayerFromTransaction(transaction);
    if (!payer) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_no_transfer_instruction",
        payer: ""
      };
    }
    const transferIx = instructions[2];
    const programAddress = transferIx.programAddress.toString();
    if (programAddress !== import_token2.TOKEN_PROGRAM_ADDRESS.toString() && programAddress !== import_token_20222.TOKEN_2022_PROGRAM_ADDRESS.toString()) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_no_transfer_instruction",
        payer
      };
    }
    let parsedTransfer;
    try {
      if (programAddress === import_token2.TOKEN_PROGRAM_ADDRESS.toString()) {
        parsedTransfer = (0, import_token2.parseTransferCheckedInstruction)(transferIx);
      } else {
        parsedTransfer = (0, import_token_20222.parseTransferCheckedInstruction)(transferIx);
      }
    } catch {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_no_transfer_instruction",
        payer
      };
    }
    const authorityAddress = parsedTransfer.accounts.authority.address.toString();
    if (signerAddresses.includes(authorityAddress)) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_transaction_fee_payer_transferring_funds",
        payer
      };
    }
    const mintAddress = parsedTransfer.accounts.mint.address.toString();
    if (mintAddress !== requirements.asset) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_mint_mismatch",
        payer
      };
    }
    const destATA = parsedTransfer.accounts.destination.address.toString();
    try {
      const [expectedDestATA] = await (0, import_token_20222.findAssociatedTokenPda)({
        mint: requirements.asset,
        owner: requirements.payTo,
        tokenProgram: programAddress === import_token2.TOKEN_PROGRAM_ADDRESS.toString() ? import_token2.TOKEN_PROGRAM_ADDRESS : import_token_20222.TOKEN_2022_PROGRAM_ADDRESS
      });
      if (destATA !== expectedDestATA.toString()) {
        return {
          isValid: false,
          invalidReason: "invalid_exact_svm_payload_recipient_mismatch",
          payer
        };
      }
    } catch {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_recipient_mismatch",
        payer
      };
    }
    const amount = parsedTransfer.data.amount;
    if (amount < BigInt(requirementsV1.maxAmountRequired)) {
      return {
        isValid: false,
        invalidReason: "invalid_exact_svm_payload_amount_insufficient",
        payer
      };
    }
    try {
      const feePayer = requirementsV1.extra.feePayer;
      const fullySignedTransaction = await this.signer.signTransaction(
        exactSvmPayload.transaction,
        feePayer,
        requirements.network
      );
      await this.signer.simulateTransaction(fullySignedTransaction, requirements.network);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        isValid: false,
        invalidReason: `transaction_simulation_failed: ${errorMessage}`,
        payer
      };
    }
    return {
      isValid: true,
      invalidReason: void 0,
      payer
    };
  }
  /**
   * Settles a payment by submitting the transaction (V1).
   * Ensures the correct signer is used based on the feePayer specified in requirements.
   *
   * @param payload - The payment payload to settle
   * @param requirements - The payment requirements
   * @returns Promise resolving to settlement response
   */
  async settle(payload, requirements) {
    const payloadV1 = payload;
    const exactSvmPayload = payload.payload;
    const valid = await this.verify(payload, requirements);
    if (!valid.isValid) {
      return {
        success: false,
        network: payloadV1.network,
        transaction: "",
        errorReason: valid.invalidReason ?? "verification_failed",
        payer: valid.payer || ""
      };
    }
    try {
      const feePayer = requirements.extra.feePayer;
      const fullySignedTransaction = await this.signer.signTransaction(
        exactSvmPayload.transaction,
        feePayer,
        requirements.network
      );
      const signature = await this.signer.sendTransaction(
        fullySignedTransaction,
        requirements.network
      );
      await this.signer.confirmTransaction(signature, requirements.network);
      return {
        success: true,
        transaction: signature,
        network: payloadV1.network,
        payer: valid.payer
      };
    } catch (error) {
      console.error("Failed to settle transaction:", error);
      return {
        success: false,
        errorReason: "transaction_failed",
        transaction: "",
        network: payloadV1.network,
        payer: valid.payer || ""
      };
    }
  }
  /**
   * Verify compute limit instruction
   *
   * @param instruction - The compute limit instruction
   * @param instruction.programAddress - Program address
   * @param instruction.data - Instruction data bytes
   */
  verifyComputeLimitInstruction(instruction) {
    const programAddress = instruction.programAddress.toString();
    if (programAddress !== import_compute_budget.COMPUTE_BUDGET_PROGRAM_ADDRESS.toString() || !instruction.data || instruction.data[0] !== 2) {
      throw new Error(
        "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction"
      );
    }
    try {
      (0, import_compute_budget.parseSetComputeUnitLimitInstruction)(instruction);
    } catch {
      throw new Error(
        "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction"
      );
    }
  }
  /**
   * Verify compute price instruction
   *
   * @param instruction - The compute price instruction
   * @param instruction.programAddress - Program address
   * @param instruction.data - Instruction data bytes
   */
  verifyComputePriceInstruction(instruction) {
    const programAddress = instruction.programAddress.toString();
    if (programAddress !== import_compute_budget.COMPUTE_BUDGET_PROGRAM_ADDRESS.toString() || !instruction.data || instruction.data[0] !== 3) {
      throw new Error(
        "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction"
      );
    }
    try {
      const parsedInstruction = (0, import_compute_budget.parseSetComputeUnitPriceInstruction)(instruction);
      if (parsedInstruction.microLamports > BigInt(MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS)) {
        throw new Error(
          "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high"
        );
      }
    } catch (error) {
      if (error instanceof Error && error.message.includes("too_high")) {
        throw error;
      }
      throw new Error(
        "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction"
      );
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExactSvmSchemeV1
});
//# sourceMappingURL=index.js.map