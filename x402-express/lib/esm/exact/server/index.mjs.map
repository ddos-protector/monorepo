{"version":3,"sources":["../../../../src/exact/server/scheme.ts","../../../../src/exact/server/register.ts"],"sourcesContent":["import type {\n  AssetAmount,\n  Network,\n  PaymentRequirements,\n  Price,\n  SchemeNetworkServer,\n  MoneyParser,\n} from \"@x402/core/types\";\nimport { convertToTokenAmount, getUsdcAddress } from \"../../utils\";\n\n/**\n * SVM server implementation for the Exact payment scheme.\n */\nexport class ExactSvmScheme implements SchemeNetworkServer {\n  readonly scheme = \"exact\";\n  private moneyParsers: MoneyParser[] = [];\n\n  /**\n   * Register a custom money parser in the parser chain.\n   * Multiple parsers can be registered - they will be tried in registration order.\n   * Each parser receives a decimal amount (e.g., 1.50 for $1.50).\n   * If a parser returns null, the next parser in the chain will be tried.\n   * The default parser is always the final fallback.\n   *\n   * @param parser - Custom function to convert amount to AssetAmount (or null to skip)\n   * @returns The service instance for chaining\n   */\n  registerMoneyParser(parser: MoneyParser): ExactSvmScheme {\n    this.moneyParsers.push(parser);\n    return this;\n  }\n\n  /**\n   * Parses a price into an asset amount.\n   * If price is already an AssetAmount, returns it directly.\n   * If price is Money (string | number), parses to decimal and tries custom parsers.\n   * Falls back to default conversion if all custom parsers return null.\n   *\n   * @param price - The price to parse\n   * @param network - The network to use\n   * @returns Promise that resolves to the parsed asset amount\n   */\n  async parsePrice(price: Price, network: Network): Promise<AssetAmount> {\n    // If already an AssetAmount, return it directly\n    if (typeof price === \"object\" && price !== null && \"amount\" in price) {\n      if (!price.asset) {\n        throw new Error(`Asset address must be specified for AssetAmount on network ${network}`);\n      }\n      return {\n        amount: price.amount,\n        asset: price.asset,\n        extra: price.extra || {},\n      };\n    }\n\n    // Parse Money to decimal number\n    const amount = this.parseMoneyToDecimal(price);\n\n    // Try each custom money parser in order\n    for (const parser of this.moneyParsers) {\n      const result = await parser(amount, network);\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    // All custom parsers returned null, use default conversion\n    return this.defaultMoneyConversion(amount, network);\n  }\n\n  /**\n   * Build payment requirements for this scheme/network combination\n   *\n   * @param paymentRequirements - The base payment requirements\n   * @param supportedKind - The supported kind configuration\n   * @param supportedKind.x402Version - The x402 protocol version\n   * @param supportedKind.scheme - The payment scheme\n   * @param supportedKind.network - The network identifier\n   * @param supportedKind.extra - Extra metadata including feePayer address\n   * @param extensionKeys - Extension keys supported by the facilitator\n   * @returns Enhanced payment requirements with feePayer in extra\n   */\n  enhancePaymentRequirements(\n    paymentRequirements: PaymentRequirements,\n    supportedKind: {\n      x402Version: number;\n      scheme: string;\n      network: Network;\n      extra?: Record<string, unknown>;\n    },\n    extensionKeys: string[],\n  ): Promise<PaymentRequirements> {\n    // Mark unused parameters to satisfy linter\n    void extensionKeys;\n\n    // Add feePayer from supportedKind.extra to payment requirements\n    // The facilitator provides its address as the fee payer for transaction fees\n    return Promise.resolve({\n      ...paymentRequirements,\n      extra: {\n        ...paymentRequirements.extra,\n        feePayer: supportedKind.extra?.feePayer,\n      },\n    });\n  }\n\n  /**\n   * Parse Money (string | number) to a decimal number.\n   * Handles formats like \"$1.50\", \"1.50\", 1.50, etc.\n   *\n   * @param money - The money value to parse\n   * @returns Decimal number\n   */\n  private parseMoneyToDecimal(money: string | number): number {\n    if (typeof money === \"number\") {\n      return money;\n    }\n\n    // Remove $ sign and whitespace, then parse\n    const cleanMoney = money.replace(/^\\$/, \"\").trim();\n    const amount = parseFloat(cleanMoney);\n\n    if (isNaN(amount)) {\n      throw new Error(`Invalid money format: ${money}`);\n    }\n\n    return amount;\n  }\n\n  /**\n   * Default money conversion implementation.\n   * Converts decimal amount to USDC on the specified network.\n   *\n   * @param amount - The decimal amount (e.g., 1.50)\n   * @param network - The network to use\n   * @returns The parsed asset amount in USDC\n   */\n  private defaultMoneyConversion(amount: number, network: Network): AssetAmount {\n    // Convert decimal amount to token amount (USDC has 6 decimals)\n    const tokenAmount = convertToTokenAmount(amount.toString(), 6);\n\n    return {\n      amount: tokenAmount,\n      asset: getUsdcAddress(network),\n      extra: {},\n    };\n  }\n}\n","import { x402ResourceServer } from \"@x402/core/server\";\nimport { Network } from \"@x402/core/types\";\nimport { ExactSvmScheme } from \"./scheme\";\n\n/**\n * Configuration options for registering SVM schemes to an x402ResourceServer\n */\nexport interface SvmResourceServerConfig {\n  /**\n   * Optional specific networks to register\n   */\n  networks?: Network[];\n}\n\n/**\n * Registers SVM payment schemes to an existing x402ResourceServer instance.\n *\n * @param server - The x402ResourceServer instance to register schemes to\n * @param config - Configuration for SVM resource server registration\n * @returns The server instance for chaining\n */\nexport function registerExactSvmScheme(\n  server: x402ResourceServer,\n  config: SvmResourceServerConfig = {},\n): x402ResourceServer {\n  if (config.networks && config.networks.length > 0) {\n    config.networks.forEach(network => {\n      server.register(network, new ExactSvmScheme());\n    });\n  } else {\n    server.register(\"solana:*\", new ExactSvmScheme());\n  }\n\n  return server;\n}\n"],"mappings":";;;;;;AAaO,IAAM,iBAAN,MAAoD;AAAA,EAApD;AACL,SAAS,SAAS;AAClB,SAAQ,eAA8B,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYvC,oBAAoB,QAAqC;AACvD,SAAK,aAAa,KAAK,MAAM;AAC7B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,WAAW,OAAc,SAAwC;AAErE,QAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,YAAY,OAAO;AACpE,UAAI,CAAC,MAAM,OAAO;AAChB,cAAM,IAAI,MAAM,8DAA8D,OAAO,EAAE;AAAA,MACzF;AACA,aAAO;AAAA,QACL,QAAQ,MAAM;AAAA,QACd,OAAO,MAAM;AAAA,QACb,OAAO,MAAM,SAAS,CAAC;AAAA,MACzB;AAAA,IACF;AAGA,UAAM,SAAS,KAAK,oBAAoB,KAAK;AAG7C,eAAW,UAAU,KAAK,cAAc;AACtC,YAAM,SAAS,MAAM,OAAO,QAAQ,OAAO;AAC3C,UAAI,WAAW,MAAM;AACnB,eAAO;AAAA,MACT;AAAA,IACF;AAGA,WAAO,KAAK,uBAAuB,QAAQ,OAAO;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,2BACE,qBACA,eAMA,eAC8B;AAE9B,SAAK;AAIL,WAAO,QAAQ,QAAQ;AAAA,MACrB,GAAG;AAAA,MACH,OAAO;AAAA,QACL,GAAG,oBAAoB;AAAA,QACvB,UAAU,cAAc,OAAO;AAAA,MACjC;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,oBAAoB,OAAgC;AAC1D,QAAI,OAAO,UAAU,UAAU;AAC7B,aAAO;AAAA,IACT;AAGA,UAAM,aAAa,MAAM,QAAQ,OAAO,EAAE,EAAE,KAAK;AACjD,UAAM,SAAS,WAAW,UAAU;AAEpC,QAAI,MAAM,MAAM,GAAG;AACjB,YAAM,IAAI,MAAM,yBAAyB,KAAK,EAAE;AAAA,IAClD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUQ,uBAAuB,QAAgB,SAA+B;AAE5E,UAAM,cAAc,qBAAqB,OAAO,SAAS,GAAG,CAAC;AAE7D,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,OAAO,eAAe,OAAO;AAAA,MAC7B,OAAO,CAAC;AAAA,IACV;AAAA,EACF;AACF;;;AC9HO,SAAS,uBACd,QACA,SAAkC,CAAC,GACf;AACpB,MAAI,OAAO,YAAY,OAAO,SAAS,SAAS,GAAG;AACjD,WAAO,SAAS,QAAQ,aAAW;AACjC,aAAO,SAAS,SAAS,IAAI,eAAe,CAAC;AAAA,IAC/C,CAAC;AAAA,EACH,OAAO;AACL,WAAO,SAAS,YAAY,IAAI,eAAe,CAAC;AAAA,EAClD;AAEA,SAAO;AACT;","names":[]}