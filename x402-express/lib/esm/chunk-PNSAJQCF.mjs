import {
  DEFAULT_COMPUTE_UNIT_LIMIT,
  DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS,
  createRpcClient
} from "./chunk-IKSTWKEM.mjs";

// src/exact/client/scheme.ts
import {
  getSetComputeUnitLimitInstruction,
  setTransactionMessageComputeUnitPrice
} from "@solana-program/compute-budget";
import { TOKEN_PROGRAM_ADDRESS } from "@solana-program/token";
import {
  fetchMint,
  findAssociatedTokenPda,
  getTransferCheckedInstruction,
  TOKEN_2022_PROGRAM_ADDRESS
} from "@solana-program/token-2022";
import {
  appendTransactionMessageInstructions,
  createTransactionMessage,
  getBase64EncodedWireTransaction,
  partiallySignTransactionMessageWithSigners,
  pipe,
  prependTransactionMessageInstruction,
  setTransactionMessageFeePayer,
  setTransactionMessageLifetimeUsingBlockhash
} from "@solana/kit";
var ExactSvmScheme = class {
  /**
   * Creates a new ExactSvmClient instance.
   *
   * @param signer - The SVM signer for client operations
   * @param config - Optional configuration with custom RPC URL
   * @returns ExactSvmClient instance
   */
  constructor(signer, config) {
    this.signer = signer;
    this.config = config;
    this.scheme = "exact";
  }
  /**
   * Creates a payment payload for the Exact scheme.
   *
   * @param x402Version - The x402 protocol version
   * @param paymentRequirements - The payment requirements
   * @returns Promise resolving to a payment payload
   */
  async createPaymentPayload(x402Version, paymentRequirements) {
    const rpc = createRpcClient(paymentRequirements.network, this.config?.rpcUrl);
    const tokenMint = await fetchMint(rpc, paymentRequirements.asset);
    const tokenProgramAddress = tokenMint.programAddress;
    if (tokenProgramAddress.toString() !== TOKEN_PROGRAM_ADDRESS.toString() && tokenProgramAddress.toString() !== TOKEN_2022_PROGRAM_ADDRESS.toString()) {
      throw new Error("Asset was not created by a known token program");
    }
    const [sourceATA] = await findAssociatedTokenPda({
      mint: paymentRequirements.asset,
      owner: this.signer.address,
      tokenProgram: tokenProgramAddress
    });
    const [destinationATA] = await findAssociatedTokenPda({
      mint: paymentRequirements.asset,
      owner: paymentRequirements.payTo,
      tokenProgram: tokenProgramAddress
    });
    const transferIx = getTransferCheckedInstruction(
      {
        source: sourceATA,
        mint: paymentRequirements.asset,
        destination: destinationATA,
        authority: this.signer,
        amount: BigInt(paymentRequirements.amount),
        decimals: tokenMint.data.decimals
      },
      { programAddress: tokenProgramAddress }
    );
    const feePayer = paymentRequirements.extra?.feePayer;
    if (!feePayer) {
      throw new Error("feePayer is required in paymentRequirements.extra for SVM transactions");
    }
    const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();
    const tx = pipe(
      createTransactionMessage({ version: 0 }),
      (tx2) => setTransactionMessageComputeUnitPrice(DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS, tx2),
      (tx2) => setTransactionMessageFeePayer(feePayer, tx2),
      (tx2) => prependTransactionMessageInstruction(
        getSetComputeUnitLimitInstruction({ units: DEFAULT_COMPUTE_UNIT_LIMIT }),
        tx2
      ),
      (tx2) => appendTransactionMessageInstructions([transferIx], tx2),
      (tx2) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx2)
    );
    const signedTransaction = await partiallySignTransactionMessageWithSigners(tx);
    const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);
    const payload = {
      transaction: base64EncodedWireTransaction
    };
    return {
      x402Version,
      payload
    };
  }
};

export {
  ExactSvmScheme
};
//# sourceMappingURL=chunk-PNSAJQCF.mjs.map